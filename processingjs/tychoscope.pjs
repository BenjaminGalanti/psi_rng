class Tychoscope{
  final int NEW_MOVE = 0;
  final int ROTATING = 1;
  final int PAUSE_1 = 2;
  final int MOVING = 3;
  final int PAUSE_2 = 4;
  //in cm
  final int ROBOT_DIAMETER = 8;
  //in cm possible value in poec'h experiment : 1cm, 2.1cm, 4.2cm ou 8.3cm
  final double AVERAGE_DISTANCE = 2.1;
  //in degrees/sec possible value in poec'h experiment : 18, 36, 72, 144
  final int ROTATION_SPEED = 144;//1000;
  //in cm/sec possible value in poec'h experiment : 1, 2, 4, 8
  final int SPEED = 8;//16;
  //in ms possible values in poec'h experiment : 100, 800, 1600, 3200
  final int PAUSE_DELAY = 100;//10;
  //Necesaire pour l'affichage du tracé du robot
  ArrayList trail_points;
  
  int pos_x;
  int pos_y;
  int previous_pos_x;
  int previous_pos_y;
  color col;
  float current_angle;
  float previous_angle;
  int circle_size;
  int circle_radius;
  int state;
  //Function of the random_angle (in ms)
  int rotation_time;
  //Function of the random distance (in ms)
  int moving_time;
  
  //Entre 0 et 360
  float random_angle;
  //Aiguille d'une montre ou sens inverse
  boolean random_clockwise;
  //Avant ou arriere
  boolean random_forward;
  //0 à 10cm
  int random_distance;
  
  int last_state_time = 0;
  int last_time = 0;
  //Current time already passed drawing the current curve
  int current_curve_drawing_time = 0;
  //Time needed to draw the current curve
  double curve_drawing_needed_time = 0;

  double last_t;
  int sample_count=0;
  
  double distance_px;
  int speed_px;
  
  Tychoscope(){
    pos_x = width/2;
    pos_y = height/2;
    previous_pos_x = pos_x;
    previous_pos_y = pos_y;
    col = color(0, 255, 0);
    current_angle = 0.0;
    previous_angle = 0.0;
    circle_size = ROBOT_DIAMETER * cm_px;
    circle_radius = circle_size / 2;
    distance_px = AVERAGE_DISTANCE * cm_px;
    speed_px = SPEED * cm_px;
    state = NEW_MOVE;
    
    trail_points = new ArrayList();
    //On créer les deux premier points, pour l'instant identiques
    int[] p1 = new int[] {pos_x, pos_y};
    trail_points.add(p1);
    int[] p2 = new int[] {pos_x, pos_y};
    trail_points.add(p2);
  }
  //Handle when < 0 or > 360
  void set_current_angle(float angle){
    current_angle = angle;   
    if(current_angle > 360){
      current_angle = current_angle - 360;
    }
    else if(current_angle < 0){
      current_angle = 360 + current_angle;
    }
  }
  
  //move the robot backward or foreward
  //also move the last point
  //manage collision
  //return true if there is a collision
  boolean add_distance(float distance_to_add){
    boolean collision = false;
    if(random_forward){
      pos_x = previous_pos_x + int(distance_to_add * cos(radians(current_angle)));
      pos_y = previous_pos_y + int(distance_to_add * sin(radians(current_angle)));
    }
    else{
      pos_x = previous_pos_x - int(distance_to_add * cos(radians(current_angle)));
      pos_y = previous_pos_y - int(distance_to_add * sin(radians(current_angle)));
    }

    //Manage collisions
    if(pos_x < 0 + circle_radius){
      pos_x = 0 + circle_radius;
      collision = true;
    }
    if(pos_x > width - circle_radius){
      pos_x = width - circle_radius;
      collision = true;
    }
    if(pos_y < 0 + circle_radius){
      pos_y = 0 + circle_radius;
      collision = true;
    }
    if(pos_y > height - circle_radius){
      pos_y = height - circle_radius;
      collision = true;
    }

    //Mise à jour du dernier point du tracé
    int[] p = trail_points.get(trail_points.size()-1);
    p[0] = pos_x;
    p[1] = pos_y;
    
    return collision;
  }

  //if first_point true, it will be an estimation
  //cause we will only know the drawing time when the second point will be choose
  //if its false, we can calculate accuratly the time
  double calcul_curve_drawing_time(boolean first_point){
    //If it's the first we interpolate and multiply them by two then add 4 PAUSE_DELAY
    if(first_point){
      return (rotation_time * 2.0) + (moving_time * 2.0) + (PAUSE_DELAY * 4);
    }
    //If not, add the current_curve_drawing_time to rotation and moving time and add only 2 PAUSE_DELAY
    else{
      return current_curve_drawing_time + rotation_time + moving_time + (PAUSE_DELAY * 2);
    }
  }
  
  void move(){
    int current_time = millis();
    int state_time = current_time - last_state_time;
    int delta = current_time - last_time;
    current_curve_drawing_time += delta;
    last_time = current_time;
    
    
    switch(state){
      case NEW_MOVE:
        //TODO : avoir un petit temps d'attente entre chaque génération de nombre aléatoire
        //Pour avoir une base de chiffre assez importante
        //random_clockwise = random(0,1) > 0.5;
        random_clockwise = rng.qrand_boolean();
        random_angle = rng.qrand_number(1, 100) * 3.6;
        random_forward = rng.qrand_boolean();
        random_distance = rng.qrand_poisson(distance_px);
        
        rotation_time = int((random_angle / float(ROTATION_SPEED)) * 1000.0);
        moving_time = int((random_distance / float(speed_px)) * 1000.0);
        /*println("Angle : " + random_angle);
        println("Sens des aiguilles d'une montre ? " + random_clockwise);
        println("En avant ? " + random_forward);
        println("Distance : " + random_distance);
        println("----------------------------------------------");*/
        //output.println(sample_count+","+random_angle+","+random_clockwise+","+random_forward+","+random_distance);
        
        //Do this after the print
        if(!random_clockwise){
          random_angle = -random_angle;
        }

        //Start a new point with for begining the last point's position
        int[] last_point = trail_points.get(trail_points.size() -1);
        int[] p = new int[] {last_point[0], last_point[1]};
        trail_points.add(p);

        //If we are drawing a new curve
        int nb_points = trail_points.size();
        boolean new_curve = nb_points >= 5 && nb_points % 2 == 1;
        if(new_curve){
          //We need to know how many time the drawing will last
          current_curve_drawing_time = 0;
          last_t = 0.0;
          curve_drawing_needed_time = calcul_curve_drawing_time(true);
        }
        else{
          curve_drawing_needed_time = calcul_curve_drawing_time(false);
        }

        sample_count++;
        last_state_time = millis();
        state = ROTATING;

        break;
      case ROTATING:
        if(state_time <= rotation_time){
          float angle_percent = float(state_time) / float(rotation_time);
          float angle_to_add = angle_percent * random_angle;
          set_current_angle(previous_angle + angle_to_add);
        }
        else{
          //Insure that we have the good angle because on my computer there is a too big delta
          set_current_angle(previous_angle + random_angle);
          previous_angle = current_angle;
          last_state_time = millis();
          state = PAUSE_1;          
        }
        break;
      case PAUSE_1:
        if(state_time >= PAUSE_DELAY){
          last_state_time = millis();
          state = MOVING;
        }
        break;
      case MOVING:
        boolean next_state = false;
        if(state_time <= moving_time){
          float distance_percent = float(state_time) / float(moving_time);
          float distance_to_add = distance_percent * float(random_distance);
          //If we hit the wall, stop moving and pass to the next state
          next_state = add_distance(distance_to_add);
        }
        else{
          next_state = true;
        }
        if(next_state){
          //Insure we've done the exact distance
          add_distance(random_distance);
          previous_pos_x = pos_x;
          previous_pos_y = pos_y;
                  
          last_state_time = millis();
          state = PAUSE_2;
        }
        break;
      case PAUSE_2:
        if(state_time >= PAUSE_DELAY){
          last_state_time = millis();
          state = NEW_MOVE;
        }
        break;
      default:
        break;
    }
  }
  void draw_line_trail(){
    fill(0);
    int nb_points = trail_points.size();
    //On affiche le tracé avant le robot comme ça le robot passe par dessus
    for(int i = 0 ; i < nb_points - 1 ; i++){
      int[] p1 = trail_points.get(i);
      int[] p2 = trail_points.get(i+1);
      line(p1[0], p1[1], p2[0], p2[1]);
    }
  }

/**
 * split a cubic curve into two curves at time=t
 * taken from : http://processingjs.nihongoresources.com/bezierinfo/
 * I just modify it a bit, so it just return the 3 last points (the first point is xa, ya) of the first splitted Bezier
 */
  PVector[] splitCubicCurve(double t, double xa, double ya, double xb, double yb, double xc, double yc, double xd, double yd) {
    // interpolate from 4 to 3 points
    PVector p5 = new PVector((1-t)*xa + t*xb, (1-t)*ya + t*yb);
    PVector p6 = new PVector((1-t)*xb + t*xc, (1-t)*yb + t*yc);
    PVector p7 = new PVector((1-t)*xc + t*xd, (1-t)*yc + t*yd);
    // interpolate from 3 to 2 points
    PVector p8 = new PVector((1-t)*p5.x + t*p6.x, (1-t)*p5.y + t*p6.y);
    PVector p9 = new PVector((1-t)*p6.x + t*p7.x, (1-t)*p6.y + t*p7.y);
    // interpolate from 2 points to 1 point
    PVector p10 = new PVector((1-t)*p8.x + t*p9.x, (1-t)*p8.y + t*p9.y);
    PVector[] points = {p5, p8, p10};
    return points; 
  }

  void draw_bezier_trail(){
    fill(0);
    int nb_points = trail_points.size();
    //Try to display Bézier curve instead of rough lines
    noFill();
    stroke(0);
    if(nb_points >= 5){
      //We want to draw a continuous Bézier curve so we use bezierVertex for that
      int[] first_point = trail_points.get(0);
      beginShape();
      vertex(first_point[0], first_point[1]);
      //As we want smoothly continous curve, we need to have the first control  point
      //of the next curve align with the last control point and the last point of the previous curve
      //So our we create this control point, the others points are from the robot.
      //it's nb_points - 2 cause the last point is always moving and we don't want a moving curve
      for(int i = 1 ; i < nb_points - 2 ; i = i+2){
        //Should we animate this curve ?
        boolean is_last_curve = i + 5 > nb_points || (i == 1 && nb_points == 6);

        int[] last_anchor_point = trail_points.get(i - 1);

        int[] c1;
        //For the first curve we do not create control point
        if(i == 1){
          //control points
          c1 = trail_points.get(i);
          start_ind = i + 1
          //increment i cause we used one more point
          i++;
        }
        else{
          //calculate c1
          //Calculate the vector of the previous control point and last point
          int[] last_control_point = trail_points.get(i - 2);
          //I should have use PVector since the beginning...
          int[] v = [last_anchor_point[0] - last_control_point[0], last_anchor_point[1] - last_control_point[1]];
          int c1 = [last_anchor_point[0] + v[0], last_anchor_point[1] + v[1]];
          start_ind = i;
        }

        int[] c2 = trail_points.get(start_ind);
        //The first anchor point is the last point of the previous curve
        //So we only care about the last point
        int[] a2 = trail_points.get(start_ind+1);

        if(is_last_curve){
          //ellipse(a2[0], a2[1], 20, 20);
        }
        if(is_last_curve){
          //Animate the last curve so that we think it's being drawn in real-time
          //The most difficulte part is to find t cause we don't know what time exactly it will take!
          double t = current_curve_drawing_time / curve_drawing_needed_time;
          t = t > 1.0 ? 1.0 : t;
          //We can't let the curve go backward
          t = t < last_t ? last_t : t;
          last_t = t;
          if(t > 0.0){
            PVector[] points = splitCubicCurve(t, last_anchor_point[0], last_anchor_point[1], c1[0], c1[1], c2[0], c2[1], a2[0], a2[1]);
            bezierVertex(points[0].x, points[0].y, points[1].x, points[1].y, points[2].x, points[2].y);
          }
        }
        else{
          bezierVertex(c1[0], c1[1], c2[0], c2[1], a2[0], a2[1]);  
        }
      }
      endShape();
    }
  }
  void draw_trail(){
    if(BEZIER_TRAIL){
      draw_bezier_trail();
    }
    else{
      draw_line_trail();
    }
  }
  
  void display(){
    if(!HIDE_TRAIL){
      draw_trail();
    }

    if(!HIDE_ROBOT){
      //Le robot est désactivé pendant la génération du pool
      //On l'affiche en gris
      if(!rng.is_ready()){
        fill(128);
      }
      else{
        fill(col);
      }
        
      if(experiment_started){
        //Robot circle
        ellipse(pos_x, pos_y, circle_size, circle_size);
        //Angle line position
        float x1 = pos_x + circle_radius * cos(radians(current_angle));
        float y1 = pos_y + circle_radius * sin(radians(current_angle));
        float x2 = pos_x - circle_radius * cos(radians(current_angle));
        float y2 = pos_y - circle_radius * sin(radians(current_angle));
        line(x1, y1, x2, y2);
        //Robot "nose"
        fill(color(255, 0, 0));
        ellipse(x1, y1, 4, 4);
      }
    }
  }

  //Return the quarter where a point is
  int get_point_quarter(int x, int y){
    if(x < width / 2 && y < height / 2){
      return 0;
    }
    else if(x >= width / 2 && y < height / 2){
      return 1;
    }
    else if(x < width / 2 && y >= height / 2){
      return 2;
    }
    else{
      return 3;
    }
  }

  //Return the number of the quarter of the screen, where the robot was more.
  //   0    |    1
  //------------------
  //   2    |    3
  int get_average_quarter(){
    int[] nb_points_per_quarter = { 0, 0, 0, 0 };
    int nb_points = trail_points.size();
    //Get all the points's quarter
    for(int i = 0 ; i < nb_points ; i++){
      int[] point = trail_points.get(i);
      int quarter = get_point_quarter(point[0], point[1]);
      nb_points_per_quarter[quarter]++;
    }

    //Then find where there is more
    int i = 0;
    int average_quarter = i;
    int max_nb_points = 0;
    for(i ; i < 4 ; i++){
      if(nb_points_per_quarter[i] > max_nb_points){
        max_nb_points = nb_points_per_quarter[i];
        average_quarter = i;
      }
    }

    return average_quarter;
  }
}
